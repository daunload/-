# CRDT

Conflict-free Replicated Data Type (충돌 없는 복제된 데이터 타입)

여러 사용자가 동일한 데이터를 동시에 편집할 때 충돌이 나지 않도록 수학적으로 해결한 데이터 구조이다.

## 핵심 원리

- **독립적인 편집**: 각 사용자는 자신의 컴퓨터에서 네트워크 연결 없이도 데이터를 수정할 수 있다.
- **자동 충돌 해결**: 변경 사항이 다른 사용자에게 전파될 때, 데이터 구조에 내장된 병합 규칙에 따라 충돌이 자동으로 해결된다. 순서가 엇갈리게 적용되어도 같은 결과가 나온다.
- **탈중앙성**: 중앙 서버 없이 Peer to Peer방식으로 동작할 수 있어, 서버 부담이 적고 시스템 확장성이 좋다.

## CRDT의 종류

1. **상태 기반**

   - **동작 방식**: 각 사용자는 데이터의 전체 상태를 다른 사용자에게 전송한다. 받은 쪽에서 자신의 상태와 받은 상태를 병합하여 업데이트한다.
   - ex) G-Counter
     - 증가만 가능한 카운터. 자신의 노드에서 카운터를 증가시키고, 동기화 시 각 노드의 카운터 값 중 최대값으로 업데이트 (유튜브 좋아요 기능)

2. **연산 기반**

   - **동작 방식**: 데이터의 전체 상태가 아닌, 수행된 연산 자체를 전송한다. 연산들이 교환 법칙을 만족하므로 어떤 순서로 적용되어도 결과는 동일하다.
   - ex) PN-Counter
     - 증가와 감소가 모두 가능한 카운터. '증가' 연산과 '감소' 연산을 각각의 G-Counter로 관리한다. 전체 값은 '총 증가량'에서 '총 감소량'을 연산한 결과값으로 업데이트

3. **위치 기반**
   - **동작 방식**: 사용자가 `A`와 `B` 글자 사이에 새로운 글자 `C`를 삽입하면, `C`는 `A`의 식별자와 `B`의 식별자 사이의 값을 갖는 새로운 식별자를 부여받는다. 예를 들어 `A`의 ID가 1이고 `B`의 ID가 2라면, `C`는 1.5와 같은 ID를 가진다. 다른 사용자가 동시에 같은 위치에 `D`를 삽입하면, `D`는 1.6과 같은 ID를 부여받는다. 이 식별자들을 정렬하면 최종 순서가 결정된다.
   - ex) Logoot / LSEQ

## CRDT의 사용사례

- 실시간 협업 편집기: 노션, 피그마
- 분산 데이터베이스: Redis
